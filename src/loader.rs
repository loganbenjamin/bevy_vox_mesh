use anyhow::{anyhow, Error};
use bevy::{
    asset::{AssetLoader, LoadContext, LoadedAsset},
    prelude::Color,
};
use block_mesh::QuadCoordinateConfig;

/// An asset loader capable of loading models in `.vox` files as usable [`bevy::render::mesh::Mesh`]es.
///
/// The meshes generated by this asset loader only use standard [`bevy::render::mesh::Mesh`] attributes for easier compatibility with shaders.
/// To get the `StandardMaterial` associated with a `.vox` file, append `#material` to the asset loading path.
/// You can load multiple models from the same `.vox` file by appending `#model{no}` to the asset loading path, where `{no}` corresponds to the model index in the file.
pub struct VoxLoader {
    /// Whether to flip the UVs vertically when meshing the models.
    /// You may want to change this to false if you aren't using Vulkan as a graphical backend for bevy , else this should default to true.
    pub(crate) config: QuadCoordinateConfig,
    pub(crate) v_flip_face: bool,
    pub(crate) convert_rgb_to_linear: bool,
}

impl AssetLoader for VoxLoader {
    fn load<'a>(
        &'a self,
        bytes: &'a [u8],
        load_context: &'a mut LoadContext,
    ) -> bevy::utils::BoxedFuture<'a, Result<(), Error>> {
        Box::pin(async move {
            self.process_vox_file(bytes, load_context)?;
            Ok(())
        })
    }

    fn extensions(&self) -> &[&str] {
        &["vox"]
    }
}

impl VoxLoader {
    fn process_vox_file<'a>(
        &self,
        bytes: &'a [u8],
        load_context: &'a mut LoadContext,
    ) -> Result<(), Error> {
        let file = match dot_vox::load_bytes(bytes) {
            Ok(data) => data,
            Err(error) => return Err(anyhow!(error)),
        };

        let palette: Vec<[f32; 4]> = file
            .palette
            .iter()
            .map(|color| {
                let rgba = color.to_le_bytes().map(|byte| byte as f32 / u8::MAX as f32);

                if self.convert_rgb_to_linear {
                    Color::rgba(rgba[0], rgba[1], rgba[2], rgba[3]).as_linear_rgba_f32()
                } else {
                    rgba
                }
            })
            .collect();

        let material = crate::material::load_material(load_context, &palette, &file.materials);

        let mut meshes = Vec::new();
        for (index, model) in file.models.iter().enumerate() {
            let (shape, buffer) = crate::voxel::load_from_model(model);
            let (name, translation) = crate::scene::extract_model_attributes(index, &file.scene);
            let mesh = crate::mesh::mesh_model(
                shape,
                &buffer,
                &palette,
                &self.config,
                self.v_flip_face,
                translation,
            );

            if let Some(name) = name {
                meshes.push(
                    load_context.set_labeled_asset(
                        &format!("model-{name}"),
                        LoadedAsset::new(mesh.clone()),
                    ),
                );
            }

            meshes.push(
                load_context.set_labeled_asset(&format!("model{index}"), LoadedAsset::new(mesh)),
            );
        }

        crate::scene::load_scene(load_context, material, &file.models, &meshes, &file.scene);

        Ok(())
    }
}
